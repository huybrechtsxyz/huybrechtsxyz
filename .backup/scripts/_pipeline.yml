
      

      
      

      # Initialize the server with initialization script
      - name: Initialize BEFORE ${{ inputs.environment }} Server ${{ matrix.label }}
        run: |
          echo "[*] Copying initialization script to remote server..."
          ssh -o StrictHostKeyChecking=no root@${{ matrix.ip }} << EOF
            mkdir -p ${{ env.APP_PATH_TEMP }}
            chmod 777 ${{ env.APP_PATH_TEMP }}
          EOF
          scp -o StrictHostKeyChecking=no \
            "./deploy/scripts/initialize-begin.sh" \
            "./deploy/scripts/initialize.env" \
            "./deploy/cluster.${{ inputs.workspace }}.json" \
            root@${{ matrix.ip }}:${{ env.APP_PATH_TEMP }}/ || {
            echo "[x] Failed to transfer before initialization script to remote server"
            exit 1
          }
          echo "[+] Copying initialization script to remote server...DONE"
          echo "[*] Executing BEFORE initializing remotely..."
          ssh -o StrictHostKeyChecking=no root@${{ matrix.ip }} << EOF
            if [ -f ${{ env.APP_PATH_TEMP }}/initialize.env ]; then
              set -a
              source ${{ env.APP_PATH_TEMP }}/initialize.env
              set +a
            else
              echo "[!] Initialization environment file not found. Exiting."
              exit 1
            fi
            chmod +x ${{ env.APP_PATH_TEMP }}/initialize-begin.sh
            ${{ env.APP_PATH_TEMP }}/initialize-begin.sh
          EOF
          echo "[+] Executing BEFORE initializing remotely...DONE"

      # Initialize the server with initialization script
      - name: Initialize ${{ inputs.environment }} Server ${{ matrix.label }}
        run: |
          if [ -f ${{ env.APP_PATH_TEMP }}/initialize.env ]; then
            set -a
            source ${{ env.APP_PATH_TEMP }}/initialize.env
            set +a
          else
            echo "[!] Initialization environment file not found. Exiting."
            exit 1
          fi
          chmod +x deploy/scripts/initialize-swarm-server.sh
          ./deploy/scripts/initialize-swarm-server.sh "${{ matrix.ip }}" "${{ matrix.private_ip }}" "${{ matrix.manager_ip }}"
          
      # Initialize the server with initialization script
      - name: Initialize AFTER ${{ inputs.environment }} Server ${{ matrix.label }}
        run: |
          echo "[*] Copying initialization script to remote server..."
          scp -o StrictHostKeyChecking=no "./deploy/scripts/initialize-end.sh" root@${{ matrix.ip }}:/tmp/app/initialize-end.sh || {
            echo "[x] Failed to transfer after initialization script to remote server"
            exit 1
          }
          echo "[+] Copying initialization script to remote server...DONE"
          echo "[*] Executing AFTER initializing remotely..."
          ssh -o StrictHostKeyChecking=no root@${{ matrix.ip }} << 'EOF'
            chmod +x /tmp/app/initialize-end.sh
            /tmp/app/initialize-end.sh
          EOF
          echo "[+] Executing AFTER initializing remotely...DONE"

  # Configure the Swarm Cluster
  # This job will run if the cache is not hit or if the initialize input is set to true
  # Configures the Swarm cluster with the provided environment variables and secrets
  # Prepares the Swarm cluster for deployment
  configuration:
    name: Configure Swarm Cluster
    needs: [restore, initialization]
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    if: always() 
    strategy:
      matrix: ${{ fromJson(needs.restore.outputs.matrix) }}
    steps:
      # Check out the repo
      - name: Check Out
        uses: actions/checkout@v4

      # Load environment variables from .env file
      - name: Get Environment Variables
        run: |
          echo "[*] Loading variables from ./src/${{ inputs.environment }}.env file..."
          while IFS='=' read -r key value || [ -n "$key" ]; do
            [[ -z "$key" || "$key" == \#* ]] && continue
            value="${value%\"}"
            value="${value#\"}"
            echo "$key=$value" >> "$GITHUB_ENV"
          done < ./src/${{ inputs.environment }}.env
          echo "[*] Loading variables from ./src/${{ inputs.environment }}.env file...DONE"

      # Set up GitHub Secrets
      - name: Get General Secrets
        uses: bitwarden/sm-action@v2
        id: get-secrets
        with:
          access_token: ${{ secrets.BITWARDEN_TOKEN }}
          secrets: |
            357068b9-9f5f-4f79-940c-b2c8016cb88f > KAMATERA_API_KEY
            6c9295a8-9fa4-4d38-8929-b2c8016d9b43 > KAMATERA_API_SECRET
            6cc5b975-56a9-4d7a-80c7-b2c90151cce0 > KAMATERA_PUBLIC_KEY
            f16fffe2-77b7-4d20-bf6c-b2c9015c71d3 > KAMATERA_PRIVATE_KEY
            5083ae32-429d-428b-b7df-b2c901441bbb > KAMATERA_ROOT_PASSWORD
            09171644-23c8-4b7f-9015-b2e5015a4572 > PLATFORM_USERNAME
            ffa5e6f9-de6a-47fa-887e-b2e5015ae1a4 > PLATFORM_PASSWORD
            5db70d74-c5db-459a-b916-b2d80126d8a3 > TRAEFIK_CLIENTID
            f5eaa406-b7cb-4ea8-b260-b2d80127303d > TRAEFIK_SECRET
            f53a76ab-b87f-4af0-9aa4-b2d1016aba2b > VERSIO_USERNAME
            3d7bbfcd-18a5-4762-9064-b2d1016aef63 > VERSIO_PASSWORD

      # Set up GitHub Secrets for Test Environment
      - name: Get Test Secrets
        if: inputs.environment == 'test'
        uses: bitwarden/sm-action@v2
        with:  
          access_token: ${{ secrets.BITWARDEN_TOKEN }}
          secrets: |
            5083ae32-429d-428b-b7df-b2c901441bbb > APP_ROOT_PASSWORD

      # Set up GitHub Secrets for Staging Environment
      - name: Get Staging Secrets
        if: inputs.environment == 'staging'
        uses: bitwarden/sm-action@v2
        with:  
          access_token: ${{ secrets.BITWARDEN_TOKEN }}
          secrets: |
            924b9526-a6cf-43c1-93a9-b2c9014494ae > APP_ROOT_PASSWORD

      # Set up GitHub Secrets for Production Environment
      - name: Get Production Secrets
        if: inputs.environment == 'production'
        uses: bitwarden/sm-action@v2
        with:  
          access_token: ${{ secrets.BITWARDEN_TOKEN }}
          secrets: |
            6db5856c-3f7f-4b62-9846-b2c90144cb0b > APP_ROOT_PASSWORD

      # Set up SSH connection
      - name: Set up SSH connection
        env:
          KAMATERA_PRIVATE_KEY: ${{ steps.get-secrets.outputs.KAMATERA_PRIVATE_KEY }}
        run: |
          mkdir -p ~/.ssh
          echo "$KAMATERA_PRIVATE_KEY" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

      # Configure Swarm Server
      - name: Configure Server
        run: |
          echo "[*] Server configuration..."
          export APP_PATH_CONF=${{ env.APP_PATH_CONF }}
          chmod +x deploy/scripts/configure-swarm-server.sh
          ./deploy/scripts/configure-swarm-server.sh "${{ matrix.ip }}" "${{ inputs.environment }}"
          echo "[+] Server configuration...DONE"
        env:
          PLATFORM_USERNAME: ${{ steps.get-secrets.outputs.PLATFORM_USERNAME }}
          PLATFORM_PASSWORD: ${{ steps.get-secrets.outputs.PLATFORM_PASSWORD }}
          TRAEFIK_CLIENTID : ${{ steps.get-secrets.outputs.TRAEFIK_CLIENTID }}
          TRAEFIK_SECRET : ${{ steps.get-secrets.outputs.TRAEFIK_SECRET }}
          VERSIO_USERNAME : ${{ steps.get-secrets.outputs.VERSIO_USERNAME }}
          VERSIO_PASSWORD : ${{ steps.get-secrets.outputs.VERSIO_PASSWORD }}

      # Configure Application Services
      - name: Configure App Services
        run: |
          echo "[*] Service configuration..."
          chmod +x deploy/scripts/configure-services.sh
          ./deploy/scripts/configure-services.sh "${{ matrix.ip }}"
          echo "[+] Service configuration...DONE"

      # Finish Configuration
      - name: Finish Configuration
        run: |
          echo "[*] Finishing configuration..."
          ssh -o StrictHostKeyChecking=no root@${{ matrix.ip }} << 'EOF'
            chmod +x /tmp/app/configure-end.sh
            /tmp/app/configure-end.sh
          EOF
          echo "[*] Finishing configuration...DONE"

  # Get all metadata.json files and set them as a matrix
  # This job will run if the rebuild input is set to true
  # It will find all metadata.json files in the src directory and set them as a matrix
  # The matrix will be used to build and push the Docker images
  docker-matrix:
    name: Get Docker Matrix
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    if: inputs.rebuild == true
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      # Check out the repo
      - name: Check Out
        uses: actions/checkout@v4

      # Generate the service matrix to build
      - name: Generate Matrix
        id: set-matrix
        run: |
          chmod +x deploy/scripts/docker-generate-matrix.sh
          ./deploy/scripts/docker-generate-matrix.sh "${{ inputs.services }}" "$GITHUB_OUTPUT"

  # Build and Push Docker Images
  # This job will run if the rebuild input is set to true
  # It will build and push the Docker images for each service in the matrix
  docker-build:
    name: Build Docker Services
    needs: [docker-matrix]
    if: inputs.rebuild == true
    runs-on: ubuntu-latest
    strategy:
      matrix: ${{ fromJson(needs.docker-matrix.outputs.matrix) }}
    steps:
      # Check out the repo
      - name: Check Out
        uses: actions/checkout@v4

      # Set up GitHub Secrets
      - name: Get General Secrets
        id: get-secrets
        uses: bitwarden/sm-action@v2
        with:
          access_token: ${{ secrets.BITWARDEN_TOKEN }}
          secrets: |
            9b5e0f00-d567-4357-a5fb-b2e30124e3fe > REGISTRY_USERNAME
            3bb3cf2a-6766-4715-8642-b2e301251ed1 > REGISTRY_PASSWORD
      
      # Set up .NET SDK
      - name: Setup .NET
        if: matrix.runtime == 'dotnet'
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ matrix.run_version }} #8.0.x

      # Build .NET Project
      - name: Build .NET Project
        if: matrix.runtime == 'dotnet'
        run: |
          echo "Building .NET project for ${{ matrix.service }}"
          cd ./src/${{ matrix.service }}/
          if [[ ! -f "${{ matrix.projectfile }}" ]]; then
            echo "::error::Project file not found at ${{ matrix.projectfile }}"
            exit 1
          fi
          dotnet restore "${{ matrix.projectfile }}"
          dotnet build "${{ matrix.projectfile }}" --no-restore --configuration ${{ matrix.build_config }}
          dotnet test "${{ matrix.projectfile }}" --no-build --verbosity normal

      # Log in to Docker Hub
      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ steps.get-secrets.outputs.REGISTRY_USERNAME }}
          password: ${{ steps.get-secrets.outputs.REGISTRY_PASSWORD }}

      # Cache Docker layers
      # This step caches the Docker layers to speed up the build process
      - name: Cache Docker layers
        uses: actions/cache@v3
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-
      
      # Extract metadata for docker
      # This step extracts metadata for the Docker image        
      - name: Extract metadata for docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ matrix.registry }}/${{ matrix.imagename }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{major}}.{{minor}}
            type=sha
            type=raw,value=${{ matrix.imagename }}
            type=raw,value=${{ inputs.environment }}
      
      # Build and push docker image
      # This step builds and pushes the Docker image to the registry
      - name: Build and push docker image
        uses: docker/build-push-action@v6
        with:
          context: ./src/${{ matrix.service }}/${{ matrix.projectname }}
          file: ${{ matrix.dockerfile }}
          push: ${{ github.event_name != 'pull_request' }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

  # Start the Environment
  # This job will run only for the first manager node in the matrix
  start:
    name: Start Environment
    needs: [restore, configuration, docker-build]
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    if: always()
    strategy:
      matrix: ${{ fromJson(needs.restore.outputs.matrix) }}
    steps:
      # Check out the repo
      - name: Check Out
        uses: actions/checkout@v4

      # Set up GitHub Secrets
      - name: Get General Secrets
        uses: bitwarden/sm-action@v2
        id: get-secrets
        with:
          access_token: ${{ secrets.BITWARDEN_TOKEN }}
          secrets: |
            f16fffe2-77b7-4d20-bf6c-b2c9015c71d3 > KAMATERA_PRIVATE_KEY

      # Set up SSH connection
      - name: Set up SSH connection
        env:
          KAMATERA_PRIVATE_KEY: ${{ steps.get-secrets.outputs.KAMATERA_PRIVATE_KEY }}
        run: |
          mkdir -p ~/.ssh
          echo "$KAMATERA_PRIVATE_KEY" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

      # Start the environment
      - name: Start Environment
        run: |
          echo "[*] Starting services..."
          ROLE="${{ matrix.role }}"
          INDEX="${{ matrix.index }}"
          echo "[*] ... Node Role: $ROLE, Index: $INDEX"
          if [[ "$ROLE" == "manager" && "$INDEX" == "1" ]]; then
            echo "[*] This is the first manager node. Starting the environment..."
            chmod +x ./deploy/scripts/start-environment.sh
            ./deploy/scripts/start-environment.sh "${{ matrix.name }}" "${{ matrix.ip }}" "${{ inputs.services }}"
          else
            echo "[*] This is not the first manager node. Skipping environment start."
            exit 0
          fi
          echo "[*] Starting services...DONE"
