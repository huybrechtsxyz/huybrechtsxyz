# Build and Deploy Jobs
name: _Infrastructure

on:
  workflow_call:
    inputs:
      environment:
        required: true
        type: string
    secrets:
      BITWARDEN_TOKEN:
        required: true

jobs:
  terraform:
    name: Terraform Plan and Apply
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    outputs:
      matrix: ${{ steps.getoutput.outputs.matrix }}
    steps:
      # Check out the repo
      - name: Check Out
        uses: actions/checkout@v4
      
      # Set up GitHub Secrets
      - name: Get General Secrets
        uses: bitwarden/sm-action@v2
        with:
          access_token: ${{ secrets.BITWARDEN_TOKEN }}
          secrets: |
            d47e736b-2db8-47d5-b46b-b2c8016ece73 > TERRAFORM_API_TOKEN
            357068b9-9f5f-4f79-940c-b2c8016cb88f > KAMATERA_API_KEY
            6c9295a8-9fa4-4d38-8929-b2c8016d9b43 > KAMATERA_API_SECRET
            6cc5b975-56a9-4d7a-80c7-b2c90151cce0 > KAMATERA_PUBLIC_KEY
            f16fffe2-77b7-4d20-bf6c-b2c9015c71d3 > KAMATERA_PRIVATE_KEY
            5083ae32-429d-428b-b7df-b2c901441bbb > KAMATERA_ROOT_PASSWORD
      
      # Set up the Terraform CLI
      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.5.7
          terraform_wrapper: false
      
      # Run Terraform to create docker swarm cluster
      - name: Run Terraform Apply
        id: tfapply
        working-directory: ./deploy
        run: |
          # Set the Terraform environment variables
          export TF_TOKEN_app_terraform_io=$TERRAFORM_API_TOKEN
          export TF_VAR_api_key=$KAMATERA_API_KEY
          export TF_VAR_api_secret=$KAMATERA_API_SECRET
          export TF_VAR_ssh_public_key=$KAMATERA_PUBLIC_KEY
          export TF_VAR_password=$KAMATERA_ROOT_PASSWORD
          export TF_VAR_environment=${{ inputs.environment }}
          export TF_LOG=DEBUG
          export ENVIRONMENT=${{ inputs.environment }}

          # Generate main.tf from template
          echo "Generating main.tf from template"
          envsubst < main.template.tf > main.tf
          rm -f main.template.tf
          cat main.tf

          # Initialize Terraform
          echo "Running terraform...INIT"
          terraform init

          # Create the plan file
          # Terraform Cloud does not support saving the generated execution plan locally at this time.
          echo "Running terraform...PLAN"
          terraform plan -var-file="vars-${{ inputs.environment }}.tfvars" -input=false

          # Apply the plan file
          echo "Running terraform...APPLY"
          terraform apply -auto-approve -var-file="vars-${{ inputs.environment }}.tfvars" -input=false

          # Get the output
          echo "Reading Terraform output..."
          echo $(terraform output -json outputdata)
          terraform output -json outputdata | jq -c '.' > tf_output.json
          cp tf_output.json /tmp/tf_output.json

      # Parse Terraform Output to find Swarm Servers
      - name: Parse Swarm Servers
        id: getoutput
        run: |
          matrix=$(jq -c '.' /tmp/tf_output.json)
          echo "matrix=$matrix" >> $GITHUB_OUTPUT

  initialization:
    name: Initialize Swarm Cluster
    needs: [terraform]
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    strategy:
      matrix: ${{ fromJson(needs.terraform.outputs.matrix) }}
    steps:
      # Check out the repo
      - name: Check Out
        uses: actions/checkout@v4

      # Set up GitHub Secrets
      - name: Get General Secrets
        uses: bitwarden/sm-action@v2
        with:
          access_token: ${{ secrets.BITWARDEN_TOKEN }}
          secrets: |
            f16fffe2-77b7-4d20-bf6c-b2c9015c71d3 > KAMATERA_PRIVATE_KEY

      # Set up GitHub Secrets for Environment
      - name: Set up SSH connection
        run: |
          mkdir -p ~/.ssh
          echo "$KAMATERA_PRIVATE_KEY" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

      # Step: Copy the key securely to the remote server using scp
      - name: Upload Private Key to Remote Server
        run: |
          scp -o StrictHostKeyChecking=no ~/.ssh/id_rsa root@${{ matrix.ip }}:/root/.ssh/id_rsa_temp || { echo "[x] Failed to transfer private key to remote server"; exit 1; }

      # Step: Copy the initialization script securely to the remote server using scp
      - name: Upload Initialization Script to Remote Server
        run: |
          # Copy the initialization scripts to the remote server
          echo "[*] Copying initialization script to remote server..."
          scp -o StrictHostKeyChecking=no "./scripts/initialize-begin.sh" root@${{ matrix.ip }}:/tmp/initialize-begin.sh || {
            echo "[x] Failed to transfer before initialization script to remote server"
            exit 1
          }
          scp -o StrictHostKeyChecking=no "./scripts/initialize-end.sh" root@${{ matrix.ip }}:/tmp/initialize-end.sh || {
            echo "[x] Failed to transfer after initialization script to remote server"
            exit 1
          }
      
      # Initialize the server with initialization script
      - name: Initialize BEFORE ${{ inputs.environment }} Server ${{ matrix.label }}
        run: |
          echo "[*] Executing BEFORE initializing remotely..."
          ssh -o StrictHostKeyChecking=no root@${{ matrix.ip }} << 'EOF'
            chmod +x /tmp/initialize-begin.sh
            /tmp/initialize-begin.sh
          EOF
          echo "[*] Executing BEFORE initializing remotely...DONE"

      # Initialize the server with initialization script
      - name: Initialize ${{ inputs.environment }} Server ${{ matrix.label }}
        run: |
          echo "[*] Executing INTERNAL initializing remotely..."
          ssh -o StrictHostKeyChecking=no root@${{ matrix.ip }} << 'EOF'
            echo "[*] Initializing server..."
            set -euo pipefail
            cd /

            configure_swarm() {
              local hostname
              hostname=$(hostname)
              echo "[*] Configuring Docker Swarm on $hostname..."

              #if docker info 2>/dev/null | grep -q "Swarm: active"; then
              if [ "$(docker info --format '{{.Swarm.LocalNodeState}}' 2>/dev/null)" = "active" ]; then
                echo "[*] Node already part of a Swarm. Skipping initialization/joining."
                if [[ "$hostname" == *"manager-1"* ]]; then
                  docker swarm join-token manager -q > /tmp/manager_token.txt
                  docker swarm join-token worker -q > /tmp/worker_token.txt
                fi
                return
              fi

              if [[ "$hostname" == *"manager-1"* ]]; then
                echo "[*] Initializing new Swarm cluster..."
                docker swarm init --advertise-addr ${{ matrix.private_ip }}

                mkdir -p /tmp
                chmod 1777 /tmp

                docker swarm join-token manager -q > /tmp/manager_token.txt
                docker swarm join-token worker -q > /tmp/worker_token.txt
                echo "[*] Saved manager and worker join tokens."
              else
                echo "[*] Joining existing Swarm cluster on ${{ matrix.manager_ip }}..."

                # SSH options for non-interactive CI (skip host key checking)
                SSH_OPTS="-o StrictHostKeyChecking=no -o ConnectTimeout=10"

                # Wait for manager token to appear (max ~60s)
                for i in {1..12}; do
                  if ssh $SSH_OPTS root@${{ matrix.manager_ip }} 'test -f /tmp/manager_token.txt && test -f /tmp/worker_token.txt'; then
                    echo "[*] Swarm tokens are available on ${{ matrix.manager_ip }}"
                    break
                  fi
                  echo "[!] Attempt $i: Waiting for Swarm tokens on ${{ matrix.manager_ip }}..."
                  sleep 5
                done

                # Final check before proceeding
                if ! ssh $SSH_OPTS root@${{ matrix.manager_ip }} 'test -f /tmp/manager_token.txt && test -f /tmp/worker_token.txt'; then
                  echo "[x] Timed out waiting for Swarm tokens. Exiting."
                  exit 1
                fi

                # Retrieve tokens
                MANAGER_JOIN_TOKEN=$(ssh $SSH_OPTS root@${{ matrix.manager_ip }} 'cat /tmp/manager_token.txt')
                WORKER_JOIN_TOKEN=$(ssh $SSH_OPTS root@${{ matrix.manager_ip }} 'cat /tmp/worker_token.txt')

                # Decide node role
                if [[ "$hostname" == *"manager-"* ]]; then
                  echo "[*] Joining as Swarm Manager..."
                  docker swarm join --token "$MANAGER_JOIN_TOKEN" ${{ matrix.manager_ip }}:2377 --advertise-addr ${{ matrix.private_ip }}
                else
                  echo "[*] Joining as Swarm Worker..."
                  docker swarm join --token "$WORKER_JOIN_TOKEN" ${{ matrix.manager_ip }}:2377 --advertise-addr ${{ matrix.private_ip }}
                fi

                echo "[*] Successfully joined Swarm cluster"

              fi
            }

            main() {
              configure_swarm
            }
            main
          EOF
          echo "[*] Executing INTERNAL initializing remotely...DONE"

      # Initialize the server with initialization script
      - name: Initialize AFTER ${{ inputs.environment }} Server ${{ matrix.label }}
        run: |
          echo "[*] Executing AFTER initializing remotely..."
          ssh -o StrictHostKeyChecking=no root@${{ matrix.ip }} << 'EOF'
            chmod +x /tmp/initialize-end.sh
            /tmp/initialize-end.sh
          EOF
          echo "[*] Executing AFTER initializing remotely...DONE"