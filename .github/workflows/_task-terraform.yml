# Initialize a Docker Swarm cluster using Terraform
name: _TerraformClusterTask

on:
  workflow_call:
    inputs:
      environment:
        required: true
        type: string
    secrets:
      BITWARDEN_TOKEN:
        required: true
    outputs:
      tf_output:
        description: "Full Terraform output JSON"
        value: ${{ jobs.terraform.outputs.tf_output }}

jobs:
  terraform:
    name: Terraform Plan and Apply
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    outputs:
      tf_output: ${{ steps.tfapply.outputs.tf_output }}
    steps:
      # Check out the repo
      - name: Check out the repo
        uses: actions/checkout@v4

      # Set up GitHub Secrets
      - name: Get Environment Secrets
        uses: bitwarden/sm-action@v2
        with:
          access_token: ${{ secrets.BITWARDEN_TOKEN }}
          secrets: |
            d47e736b-2db8-47d5-b46b-b2c8016ece73 > TERRAFORM_API_TOKEN
            357068b9-9f5f-4f79-940c-b2c8016cb88f > KAMATERA_API_KEY
            6c9295a8-9fa4-4d38-8929-b2c8016d9b43 > KAMATERA_API_SECRET

      # Set up GitHub Secrets for Test Environment
      - name: Get Test Secrets
        if: ${{ inputs.environment == 'test' }}
        uses: bitwarden/sm-action@v2
        with:  
          access_token: ${{ secrets.BITWARDEN_TOKEN }}
          secrets: |
            6cc5b975-56a9-4d7a-80c7-b2c90151cce0 > KAMATERA_PUBLIC_KEY
            5083ae32-429d-428b-b7df-b2c901441bbb > APP_ROOT_PASSWORD

      # Set up GitHub Secrets for Staging Environment
      - name: Get Staging Secrets
        if: ${{ inputs.environment == 'staging' }}
        uses: bitwarden/sm-action@v2
        with:  
          access_token: ${{ secrets.BITWARDEN_TOKEN }}
          secrets: |
            4dc11520-0305-47fd-bd2a-b2c901526d65 > KAMATERA_PUBLIC_KEY
            924b9526-a6cf-43c1-93a9-b2c9014494ae > APP_ROOT_PASSWORD

      # Set up GitHub Secrets for Production Environment
      - name: Get Production Secrets
        if: ${{ inputs.environment == 'production' }}
        uses: bitwarden/sm-action@v2
        with:  
          access_token: ${{ secrets.BITWARDEN_TOKEN }}
          secrets: |
            ee623c15-a017-44c5-91e0-b2c9015298a9 > KAMATERA_PUBLIC_KEY
            6db5856c-3f7f-4b62-9846-b2c90144cb0b > APP_ROOT_PASSWORD

      # Set up the Terraform CLI
      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.5.7

      # Run Terraform to create docker swarm cluster
      - name: Run Terraform Apply
        id: tfapply
        working-directory: ./deploy
        run: |
          # Set the Terraform environment variables
          export TF_TOKEN_app_terraform_io=$TERRAFORM_API_TOKEN
          export TF_VAR_api_key=$KAMATERA_API_KEY
          export TF_VAR_api_secret=$KAMATERA_API_SECRET
          export TF_VAR_ssh_public_key=$KAMATERA_PUBLIC_KEY
          export TF_VAR_password=$APP_ROOT_PASSWORD
          export TF_VAR_environment=${{ inputs.environment }}
          export TF_LOG=DEBUG
          export ENVIRONMENT=${{ inputs.environment }}

          # Generate main.tf from template
          echo "Generating main.tf from template"
          envsubst < main.template.tf > main.tf
          rm -f main.template.tf
          cat main.tf

          # Initialize Terraform
          echo "Running terraform...INIT"
          terraform init

          # Create the plan file
          # Terraform Cloud does not support saving the generated execution plan locally at this time.
          echo "Running terraform...PLAN"
          terraform plan -var-file="vars-${{ inputs.environment }}.tfvars" -input=false

          # Apply the plan file
          echo "Running terraform...APPLY"
          terraform apply -auto-approve -var-file="vars-${{ inputs.environment }}.tfvars" -input=false
          echo "Running terraform...OUTPUT"
          terraform output -json > tf_output.json
          echo "Reading Terraform output..."
          ls -la
          cat tf_output.json

          # Parse the output
          # Example output
          # {
          #   "include": [
          #     {
          #       "role": "manager",
          #       "ip": "192.0.2.1",
          #       "private_ip": "10.0.0.1"
          #     },
          #     {
          #       "role": "worker",
          #       "ip": "192.0.2.2",
          #       "private_ip": "10.0.0.2"
          #     },
          #     {
          #       "role": "worker",
          #       "ip": "192.0.2.3",
          #       "private_ip": "10.0.0.3"
          #     }
          #   ]
          # }
          # echo "Trying tf_output.json"
          # ip=$(jq -r '.manager_public_ips.value[0]' tf_output.json)
          # echo "The IP is $ip"
          # echo "Parsing tf_output.json"
          # managers=$(jq '.manager_public_ips.value' tf_output.json)
          # workers=$(jq '.worker_public_ips.value' tf_output.json)
          # managers_internal=$(jq '.manager_private_ips.value' tf_output.json)
          # workers_internal=$(jq '.worker_private_ips.value' tf_output.json)
          # MATRIX=$(jq -n \
          #   --argjson managers "$managers" \
          #   --argjson workers "$workers" \
          #   --argjson managers_internal "$managers_internal" \
          #   --argjson workers_internal "$workers_internal" \
          #   '{
          #     include: (
          #       [$managers, $managers_internal] | transpose | map({role: "manager", ip: .[0], private_ip: .[1]}) +
          #       [$workers, $workers_internal] | transpose | map({role: "worker", ip: .[0], private_ip: .[1]})
          #     )
          #   }')
          MATRIX="abc"
          echo "tf_output=$MATRIX" >> $GITHUB_OUTPUT
       